# Babelute

Javascript Internal DSMM Framework.

DSMM is the beginning of a new era.
It deeply changes the way of thinking developpement process, code and design.
Because it simply mimics the way that we think.

Before diving in high level abstractions, I'll ask you to answer seriously a really practical question :

Imagine a (big) customer from food industry which makes cakes and pies and comes to your office and ask you to rewrite all their IT stuffs about their receipts.
They want receipts that should be defined and used internaly (by pros) or externaly (by noobs).
That should automatically gives dietetic score, composition, alergen list, time and weight estimation, and overall price.
That should be exposed on their website or mobile app and downloadable as pdf or svg in many languages.
And, why not, if they could drive a robot to make pies it could be interesting. :)

How much time to make a valuable demo and an estimation, with only those limited informations, to get the job ?
How to start, how to iterate, what to design, etc. ?

Depending on your speciality (back-end, front-end, full-stack, data-scientist, UIX expert, ...) you will imagine plenty of solutions with big bunches of technologies, frameworks, db models, restful apis, patterns, views, forms, styles, use cases, etc.

And you where right. Finally it will be all this.

But how to start and iterate ?
What could be a valuable demo ? 
Could we provide almost all needed functionalities in this demo ?
How to make it as a real iteration base (to not throw it away just after demo time) ?
And... How much time it could take to provide ?

Even if the mission is (or seems) not so complex, those are dificults questions.

Let's try with the "classical" approach :


To provide a demo, we need two or three things : 
- Model(s)
- Presentation View(s)
- Edition/Creation View(s)

Let's take a look to well-known receipt plateform to get inspiration : 
http://www.marmiton.org/recettes/recette_tarte-aux-pommes-a-l-alsacienne_11457.aspx


















What I'm pretty sure is that you'll never answer a couple of hours...

But in fact, that's the time needed to provide a simple but meaningfull and valuable demo, which will serve as base for further iterations (whatever technology stack have we choosed), and that allows us to estimate and plan next steps.

Better, in that time, we will resolve the receipts modeling problem for any type of cooking (not only for pies and cake).
And we would be able to propose our solution to the community as a standard candidate for Cooking Modeling, usable by anyone in plenty of cases.
(Same thing for dietetic/composition/alergen/weight/time/price/... repports.)

Naturally, we'll make things really usable and reusable, not only for you that create the system, but for anyone that understand a little bit in cooking.

And even more, our datas will be much more smart and precise than any classical Model.

In short, to achieve this, we (only) need :
- an Internal Abstract DSL for receipts modeling.
- a bunch of translations and output rules for :
	- html/svg/pdf representations
	- dietetic/composition/alergen/weight/time/price repports
	- i18n
	- robot driving
- a DSL sentence editor for writing receipts 

And that's it...

Of course none of them will be perfect, but that's not the point.
What's really important here, is that we could directly iterate on the higher level to be sure that we understoud the problem at the right place : aka the receipt model.


Let's do it...







What do we have finally ?

Yep our cool demo that do (or could easily do) __everything asked__ by customer.. ok but what else ?

In fact, for free, we have already so much things with so much deep and great implications in so much seemly separated Domains......

So much that it is dizzying....

What's a babelute formally ?

=> A simple tree (a forest (list) of tree where nodes could hold other(s) forest(s))
and where leafs are primitives values.

=> 



So let's check all by points of view :

- seen as (Fluent) Internal DSL
	- allow simple and meaning full programation
	- allow real separation of concern
	- allow best quality communication with customers (or through experts)
	- allow fast discovering of what are atoms and what are compounds (RISC/CISC)
 	- allow highest level of domain resolution (receipt DSL is for all cooking receipt. not just for cake.)
 	- give pure separated __exposed__ and simplest logic
	==> best quality descriptive program
	==> customers become programers (at least scripters)
	==> in fact "Internal DSL" approach is "script oriented"

	==> Sentences are everything : think about general purpose programation languages, arithmetic, algebra and all math, Human languages, etc. etc. etc.
	==> that's not a coincidence that human language is based on sentences : the world is based on sentences.

	==> Welcome in Semantic Era
	==> We'll never have something better than a DSL to express Domain problems.


- seen as (Descriptive) Template
	- allow full reusability
	- allow natural structuration
	- focus on descriptive approach first

- seen as Facade
	- allow free implementation
	- dead simple
	- absolutly unobstrusive : no constraints at all

- seen as Data Modeling
	- universal
	- complete information (order, lexic, structure, relation, time, ...)
	- highest precision
	- optimal minification
	- highly portable
	- auto parsable
	==> highest quality data

	==> Could be a new DB core principle... or plugged it everywhere we could store a string... 

- seen as Structured Document Model (xml like, and so (x)html or any other variant)
	- First Degree
	- allow update/modification
	- allow query
	- allow generic GUI
	- allow validation

- seen as an ADT

- seen as AST
	- allow meta-programation
	- allow full introspection
	- allow auto testing (particulary with if/each)
	- allow fastest and cleanest diffing
		=> AST is the highest tree : much more cutable
		=> AST is stable : no hard transformation of nodes

- seen as Model or Transformation Rule in Model Driven Approach
	- allow translations/transformations between models
	- allow environment dependent interpretation/implementation/output
	- allow documentation and reports auto generations
	==> That's complete and real MDD that rocks

	It even explains why classical MDD based on UML is a failure :
	- UML is a set of fixed DSLs (class, sequence, use case, ... diagrams and their lexems).
	- classical MDD means using ONE language (UML) on top
	and impose to express any problems through its DSLs (and derived Dialects) 
	and impose to do that at each level

	DS(M)M says that top language should be ad'hoc and precisly defined, 
	and so different for all kind of treated problems. 
	We use directly the right language and impose nothing.
	It allows easy connection between Models and natural structuration.

- seen as Web Ontology Bridge
	- easy classification
	- ontologic friendly
	- allow best precision query
	- declarative is suffisiant
	==> Welcome to Babelute DSL Core
	==> Best quality SEO

- seen as Machine Intelligence Tools
	- allow inference
	- allow pattern or similarity discovering
	- allow continuous feeding
	==> DS(M)M is how we think
	==> babelute's transformations are the exact inverse processus than recognition
	==> babelute is what we have in mind when we have correctly understoud something
	==> full link with deep-learning

	==> Rich and smart data make us (and machines) more inteligent

	(cela plaide en faveur d'une IA forte)

- seen as Formal Gramar
	- lexic + documentation rules = formal gramar
	==> we could use it to parse/recognize atoms to compounds
	==> it's easy to automaticaly derivate the Finit State Machine needed to do the job nicely
	==> which could be LL(k) due to natural tree structuration and left-to-right writing order

- seen as Software Development Method
	- Agile-that-never-been-so-easy : 
		allow really simple and direct almost-procedural method to design/develop/plan/iterate/...
	- method :
		- which is the domain ?
		- how do we talk about it ?
		- which are lexems ?
		- are they atoms or compounds ?
		- which transformations are needed ?
			- find target DSLs and iterate method
		- which implementations are needed ?
		- Don't Repeat Yourself (DRY)
		- be descriptive
		- be more DRY
		- think Domain purity. avoid Leaky Abstractions.
		- hide technologies deepest possible.

	==> easy iterate, easy change, easy design, easy reuse, easy instanciate, easy implement, easy represent, easy test, ...	
	==> welcome to DRY programing

	==> most pertinent, valuable, adequate result :
		For the end-customers : Domain are the most important. Not DB Model.
		Customer never change its business domain. Or he make another business.
		But he would change DB Model. And any software part.

	- allow full TDD approach :
		- we start by describing what we want, which is the key of TDD.
		- every level is atomically testable
		- divide to conquer. and iterate. then recompose. 
		==> Finally : everything is always, deeply, immediatly and often automatically testable.

And cherry-on-the-cake but not at all the least :
	- allow real and complete sharing of works : it's no more technologies, it's universal domain-model-data.
	- totally portable, totally reusable
	- Domains are the most stable things we have.
	- Shared DSL are true for today, yesterday and tomorrow (or almost)
	- each translation between DSL could drasticaly help developpers community
	
	==> Welcome in Sharing Era




So from a simple tree we have derivate through :
	- Internal Fluent DSLs and Semantic Era
	- Descriptive Templating 
	- Facade Simplicity
	- Smart Interchangeable Data Modeling
	- Structured Document Model
	- AST
	- Model/Transfo in MDD
	- The missing Web Ontology Bridge
	- Machine Intelligence Tools
	- Automatisable Formal Gramar
	- Agile/TDD dev method
	- Sharing Era

Each time you write any babelute : you receive ALL this for the same price.
And if you use the right lexic, with well choosed lexems, you should have the purest form, optimaly exposed, semanticaly perfect (in regard of actual domain knowledge) view of your problem and its resolution(s).

And if you don't, it's just because you (or humanity) haven't fully understand yet the problem you search to resolve. Because you simply missing how to make clear sentences that expose practically and unambigously what you want.

And all Babelute interest come from that : many highly different modern Software Engineering foundamentals aspects are gathered, elegantly resolved and transported implicitly (but unambigously) on a simple tree data structure, that should reflect, in an ideal world, the best knowledge avaiable from a Domain.

Particulary, this simple data structure form the simplest and complete bridge between highly practical development considerations (we want to produce clean code quickly and simply) and highly theorical ones (Machine Learning, Data-Science, Ontologies, Software Dev Method, ...).

And all that is accessible in any general-purpose-coding-language.

For all this reason,  Babelute should become :
	- the next gen Light Practical Ontology System
		- used heavily by all Search Engine and Machine Intelligence actors
		- and so exposed by web/app/data/... actors
	- the next gen Data Interchange Format with native parsers in actual VMs/Compilers/STD/... (js with browsers, node, ... and of course any others general-purpose language)
	- the next gen standards for MDD
	- the next gen smart DB core principle
	- the next gen Agile Method Canvas
	- the next gen paradigm that everybody should learn at school : everybody is a scripter
	- the biggest IT community, working around Babelute DSL core

There is two universal answers to every question... 42 and Babelute... ;)



So we have migrate from : 
Software Design
Data Design
Knowledge Design
Sentences for everything




=> Notion de safe dependencies update : (de nouveau : WOW !!)
	check si arbre de dépendances peut être updaté : exemple : toolschain dsl : comme on connait la version du DSL babelute utilisé pour décrire le tools chain : 
		on peut savoir si (et jusqu'ou) on peut avancer de version pour le moteur d'interprétation

	bcp mieux que supputation versionning sémantique




# Postface

What have been discussed before are IT related point of views.

But there are (much) more transversal links :
As Systemic, autogeneration and law design : DSLs are highly generative systems because of freedom of sentences construction (which is one of the key of the world complexity) (For the little history : it's really one of the foundamentals theory which has lead to babelute development)

From that point we could derive to Government Policies, to Evolution Theory and many more seemly unrelated Domain

or ADN link : understanding ADN sequence is finding DSL sentences that has produce them

Or even more highly Theorical considerations
As Dsl and Goedel Incompletude Theorem : as we define languages that produce ASTs, we should work with complete languages (no cycles)
or DSM/Babelute Tools Theory










Tools Theory


Information Quality Theory


https://en.wikipedia.org/wiki/Pragmatics  == Actions

https://en.wikipedia.org/wiki/Semantics

https://en.wikipedia.org/wiki/Semantic_data_model


https://en.wikipedia.org/wiki/Information_model

Fact-based Modeling

https://en.wikipedia.org/wiki/Object-role_modeling#Fact-based_modeling

http://www.slideshare.net/drrubrico/semantics-meanings-of-language

Systemic Connection : 

	Atom + Compounds = Element of the system + Interactions = words from lexics

	Interactions Sequences = sentences

	System is mush more than its parts sum.
	System is element, interactions grammar, AND sequences.

	Systemic talks about generability.

	System Qualities Theory
		most important quality : genarability

		Because we are human : 
			we need also : simplicity, understandibility


http://link.springer.com/chapter/10.1007/11568346_41

http://www.slideshare.net/baojie_iowa/semantic-information-theory-in-20-minutes

 syntactic compression methods

Measuring the Perceived Semantic Quality of Information Models
http://www.sciencedirect.com/science/article/pii/S1574119213000953



Sentences are everything.
	Think about your code. Is just sentences made with few keywords and some literals and some characteres to delimit and structure.
	Think about algebra... Same thing... just sentences. 
	And they are both so powerful. So much smart things have been written with them...

	The good news is that (almost) all human activities are naturaly described by sentences.
	Sure that to explain finely a mouvement only with words is not easy by example...
	But we could easily desribe the whole humanity history and so much more with relatively few words.

	Sentences are how our brain works when it reasons or communicates.
	It's all about playing with right words along with well choosed abstraction level and structure.
	With that, we are able to generate an infinity of smart thinking.

	And DSLs (all of them, from any domains of real life) are what communities have forged, often since decade, with expertise and patience, and that has become the way of thinking their problems.
	In fact, DSLs catch the knowledge of their respective domain in few words and allow us to make sentences with them.


Universal Unambigous Sentences 
	
	General Definition of Information (GDI) compliance

		Factual 
		Instructional

	Applications
		- SEO, Data Science and Ontology Bridge

		- Technology Agnostic Informations : welcome in sharing era.


	Informations 
		= Data + meaning ==> meaning = DSL grammar = lexems relations
		= data + questions 
		= primary + meta + derivated

		==> Information = Data + grammar + meta + derivated (questions answers)

	Level Of Abstraction


Critère de comparaison de DSL :

	- active or not (factual/instructional, description/action)

	- agnosticity purity
	- atom/shortcut/compounds ratios
	- level purity


La désambiguïsation lexicale est la détermination du sens d'un mot dans une phrase lorsque ce mot peut avoir plusieurs sens possibles. Dans la linguistique informatique, la désambiguïsation lexicale est un problème non résolu dans le traitement des langues naturelles et de l'ontologie informatique.
Désambiguïsation lexicale — Wikipédia
https://fr.wikipedia.org/wiki/Désambiguïsation_lexicale

Word-sense disambiguation
In computational linguistics, word-sense disambiguation (WSD) is an open problem of natural language processing and ontology. WSD is identifying which sense of a word (i.e. meaning) is used in a sentence, when the word has multiple meanings. The solution to this problem impacts other computer-related writing, such as discourse, improving relevance of search engines, anaphora resolution, coherence, inference et cetera.
https://en.wikipedia.org/wiki/Word-sense_disambiguation

https://en.wikipedia.org/wiki/Lexical_semantics#Semantic_networks

https://en.wikipedia.org/wiki/Pragmatic_theory_of_information

https://plato.stanford.edu/entries/information-semantic/#1.2

http://octavia.zoology.washington.edu/publications/BergstromAndRosvall09.pdf

http://wiki.aardrock.com/Semantic_Transmission_and_the_Emergent_Mind

http://visual-memory.co.uk/daniel/Documents/short/trans.html#G

https://en.wikipedia.org/wiki/Semantic_change

http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.295.4692&rep=rep1&type=pdf

https://bi.snu.ac.kr/~scai/Info/AI/Fusion,%20Propagation,%20and%20Structuring%20in%20Belief%20Networks.pdf

http://philsci-archive.pitt.edu/2536/1/iimd.pdf


 * Domain Specific (Multi)Modeling (using DSL at all levels) solves many software design problems.
 * From developpement process (how to start, what and how to design, how to iterate, ...) 
 * to how to understand, design and articulate business related problems and/or pure code logics.




antifotizomai (exposed to light)
ekthésimos (exposed - isolable)
ektheatrízo (exposed on stage)
enaíthrios (fully exposed)
diafrazo (show plainly)


Good DSL developpement is the exact opposite than Cryptography