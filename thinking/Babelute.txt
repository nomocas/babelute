# Theory part

## So What does it try to resolve

Domain Specific Modeling
- [[1]](https://metacase.com/webinar/Domain_Specific_Modeling_76_cases_of_MDD_that_works_Nov2009.pdf) DSM : 76 cases of MDD That works
- [[2]](http://s3.amazonaws.com/academia.edu.documents/42473462/Domain_specific_modeling20160209-12929-16vmdfi.pdf?AWSAccessKeyId=AKIAJ56TQJRTWSMTNPEA&Expires=1481808605&Signature=33JXUlf1xs9BZBWjiDjGo3XTJ7I%3D&response-content-disposition=inline%3B%20filename%3DDomain_specific_modeling.pdf) Domain specific modeling (Robert France, Bernhard Rumpe, 2005)
- [[4]](http://www.dsmforum.org/why.html) DSM Forum

Domain Specific MultiModeling

> Domain-specific multimodeling[1] is a software development paradigm where each view is made explicit as a separate domain-specific language (DSL).
src : [wikipedia](https://en.wikipedia.org/wiki/Domain-specific_multimodeling)

- [[1]](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.453.9934&rep=rep1&type=pdf) Hessellund, Anders (2009). "Domain-Specific Multimodeling". IT University of Copenhagen, Denmark. 2009.


DSM is true, practical MDD that rocks. Yeah... Finally ! ;)

MDD is where (Meta)Models are the only first class citizens and where everything else is transformations and could be thrown and replaced at any time.

Classical MDD is broadly based on UML (Meta)Modeling and propriatary transformations tool boxes.
The main idea is to maintain and focus on the business (Meta)Models through years and to provide automated transformation pipes (from UML to code) to produce runable and testable Apps (any sort of...) that will evolve and die much faster than (Meta)Models.

Great idea ! But... Until now, it hasn't produce all promised benefits (precise and complete UML modeling is quite heavy and make things less clear than needed (too generic), and transformations rules are hard to maintain or to closely coupled with monolithics propriatary environnement). So for the moment it's clearly far more  expensive than good Agile approach...

With DSM, Models and instances are not seen as UML nor Object any more. Models are DSLs and instances are sentences (even graphical) of those DSLs.
DSMM says that we could express any DSL by another one __when we need to precise things in a particular context__.

Babelute tries to provide tools for defining meta-models (DSLs definitions) and transformations/translations between them with simple Method Chaining pattern.

Which kind of things could be modeled ? __Everything that could be describe with words__ and __simple parameters__ (i.e. where an __Internal DSL__ could be found).

By example, describing a mouvement accuratly with only words is highly difficult and in many case impossible, and so Internal DSL based on words lexics __only__ seems not to be the best (or complete) solution. (we would need coordinate system and mathematics objects to do it)

But the "logic" behind the movement could be expressed with words that could be mixed with coordinate system or any other DSL (algebra is a DSL by example). 
```javascript
var m = Babelute.initializer('myMovementLexic');

m.moveTo(12, 30, m.duration(200).bounce(3))
.delay(300)
.oscillateHorizontally(20 /* pix left and right */, 150 /* ms for each cycle */)
.cinematic('3x - 2 = y');
```

Or in [UUS](https://github.com/nomocas/babelute-uus) style :

```
#myMovementLexic:
	moveTo(12, 30, duration(200) bounce(3))
	delay(300)
	oscillateHorizontally(20 /* pix left and right */, 150 /* ms for each cycle */)
	cinematic("3x - 2 = y")
```

What is sure, there will never be a lexical Internal DSL for expressing RegExp by example.

## Creating Lexics

### Logical Atoms 

Reduction principle

### Shortcut

### Compounds words

RIS vs CIS

### Extending lexics

### Atomic-Babelute vs First-Level-Babelute

## Implementing Actions

## Advice for creating DSL

- write sentences (what you finally want) before all
- be descriptive
- be DRY
- be pure
- maximize holded informations
- think transformability

## Fluent Interfaces as DSL

Expressing DSL with Fluent Interface is something that is well known today.
The term "Fluent Interface" comes from Martin Fowler's [2005 article](http://martinfowler.com/bliki/FluentInterface.html) where he associated clearly Internal DSL and fluency.

Fluent interfaces does not mean necessary Method Chaining. It's just one way to achieve it.
And Method Chaining doesn't mean necessary Internal DSL.

Fluent Internal DSL are much more about choosing right words with right semantics for optimally expressing particular problems through readable and meaningful sentences. Not simply chaining calls.

Examples of Domain Specific Language expressed with Method Chaining :

SQL in JAVA : http://www.jooq.org/
```java
create.select(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME, count())
      .from(AUTHOR)
      .join(BOOK).on(AUTHOR.ID.equal(BOOK.AUTHOR_ID))
      .where(BOOK.LANGUAGE.eq("DE"))
      .and(BOOK.PUBLISHED.gt(date("2008-01-01")))
      .groupBy(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)
      .having(count().gt(5))
      .orderBy(AUTHOR.LAST_NAME.asc().nullsFirst())
      .limit(2)
      .offset(1)
```
Other example not expressed with Method Chaining : 
RTF Doc construction in JAVA : https://github.com/ullenboom/jrtf/
```java
rtf().section(
   p( "first paragraph" ),
   p( tab(),
      " second par ",
      bold( "with something in bold" ),
      text( " and " ),
      italic( underline( "italic underline" ) )     
    )  
).out( out );
```

Further reading :
- http://leecampbell.blogspot.be/2008/11/method-chaining-to-create-your-dsl.html
- https://sanaulla.info/2013/05/30/creating-internal-dsls-in-java-java-8-adopting-martin-fowlers-approach
- https://msdn.microsoft.com/en-us/magazine/ee291514.aspx
- https://books.google.be/books?id=EhOXBQAAQBAJ&pg=PA403&lpg=PA403&dq=method+chaining+DSL&source=bl&ots=vMd25Y86E1&sig=d7SbHZoiLA8X1g4nsoo5Ph5kHTA&hl=fr&sa=X&ved=0ahUKEwiR_-32usvOAhUSahoKHTk2C9Y4ChDoAQgwMAM#v=onepage&q=method%20chaining%20DSL&f=false

## Translation Chain : From High Level to Code Level

Community of Abstract and Concreet DSLs.

Auto-parsing

## Todo soon

- debug and report
- open problem : meta-model and model evolution and versioning
	(maybe introduce Consumer Contract Driven logics)

## Further

- coordination problem and method








/*****************************************************************************************************************************
 *****************************************************************************************************************************/



# Babelute

Javascript Internal DSMM Framework.


> The only way we’ll be able to keep up with the exponentially increasing complexity will be to decrease the complexity of understanding programs. To maintain the goliath apps of tomorrow, we must learn to build more expressive code. We must learn to write programs that are easier to reason about, debug, create, analyze, and understand. __Eric Elliott__

Third Programming Revolution = DDD, DS(M)M
	add abstractions levels
	purify them
	think top-bottom


Internal-DSL-for-DS(M)M framework
	Internal, external and Leaky Abstractions

Revolution 3.1 : UUS

	UUS = serialized form of DSL structured sentences : principal aim : store and exchange sentences easily.

	technologie agnostic and sharing era
	Semantic Web
	Machine Learning
	Human Language Parser
	ET Messages

DSMM is the beginning of a new era.
It deeply changes the way of thinking developpement process, code and design.
Because it simply mimics the way that we think.

Before diving in high level abstractions, I'll ask you to answer seriously a really practical question :

Imagine a (big) customer from food industry which makes cakes and pies and comes to your office and ask you to rewrite all their IT stuffs about their receipts.
They want receipts that should be defined and used internaly (by employee) or externaly (by noobs).
That should automatically gives dietetic score, composition, alergen list, time and weight estimation, and overall price.
That should be exposed on their website or mobile app and downloadable as pdf or svg in many languages.
And, why not, if they could drive a robot to make pies it could be interesting. :)

How much time to make a valuable demo and an estimation, with only those limited informations, to get the job ?
How to start, how to iterate, what to design, etc. ?

Depending on your speciality (back-end, front-end, full-stack, data-scientist, UIX expert, ...) you will imagine plenty of solutions with big bunches of technologies, frameworks, db models, restful apis, patterns, views, forms, styles, use cases, etc.

And you where right. Finally it will be all this.

But how to start and iterate ?
What could be a valuable demo ? 
Could we provide almost all needed functionalities in this demo ?
How to make it as a real iteration base (to not throw it away just after demo time) ?
And... How much time it could take to provide ?

Even if the mission is (or seems) not so complex, those are dificults questions.

Let's try with the "classical" approach :


To provide a demo, we need two or three things : 
- Model(s)
- Presentation View(s)
- Edition/Creation View(s)

Let's take a look to well-known receipt plateform to get inspiration : 
http://www.marmiton.org/recettes/recette_tarte-aux-pommes-a-l-alsacienne_11457.aspx













What I'm pretty sure is that you'll never answer a couple of hours...

But in fact, that's the time needed to provide a simple but meaningfull and valuable demo, which will serve as base for further iterations (whatever technology stack have we choosed), and that allows us to estimate and plan next steps.

Better, in that time, we will resolve the receipts modeling problem for any type of cooking (not only for pies and cake).
And we would be able to propose our solution to the community as a standard candidate for Cooking Modeling, usable by anyone in plenty of cases.
(Same thing for dietetic/composition/alergen/weight/time/price/... repports.)

Naturally, we'll make things really usable and reusable, not only for you that create the system, but for anyone that understand a little bit in cooking.

And even more, our datas will be much more smart and precise than any classical Model.

In short, to achieve this, we (only) need :
- an Internal Abstract DSL for receipts modeling.
- a bunch of translations and output rules for :
	- html/svg/pdf representations
	- dietetic/composition/alergen/weight/time/price repports
	- i18n
	- robot driving
- a DSL sentence editor for writing receipts 

And that's it...

Of course none of them will be perfect, but that's not the point.
What's really important here, is that we could directly iterate on the higher level to be sure that we understoud the problem at the right place : aka the receipt model.


Let's do it...







What do we have finally ?

Yep our cool demo that do (or could easily do) __everything asked__ by customer.. ok but what else ?

In fact, for free, we have already so much things with so much deep and great implications in so much seemly separated Domains......

So much that it is dizzying....

What's a babelute formally ?

=> A simple tree (a forest (list) of tree where nodes could hold other(s) forest(s))
and where leafs are primitives values.

=> 



So let's check all by points of view :

- seen as (Fluent) Internal DSL
	- allow simple and meaning full programation
	- allow real separation of concern
	- allow best quality communication with customers (or through experts)
	- allow fast discovering of what are atoms and what are compounds (RISC/CISC)
 	- allow highest level of domain resolution (receipt DSL is for all cooking receipt. not just for cake.)
 	- give pure separated __exposed__ and simplest logic
	==> best quality descriptive program
	==> customers become programers (at least scripters)
	==> in fact "Internal DSL" approach is "script oriented"

	==> Sentences are everything : think about general purpose programation languages, arithmetic, algebra and all math, Human languages, etc. etc. etc.
	==> that's not a coincidence that human language is based on sentences : the world is based on sentences.

	==> Welcome in Semantic Era
	==> We'll never have something better than a DSL to express Domain problems.


- seen as (Descriptive) Template
	- allow full reusability
	- allow natural structuration
	- focus on descriptive approach first

- seen as Facade
	- allow free implementation
	- dead simple
	- absolutly unobstrusive : no constraints at all

- seen as Data Modeling
	- universal
	- complete information (order, lexic, structure, relation, time, ...)
	- highest precision
	- optimal minification
	- highly portable
	- auto parsable
	==> highest quality data

	==> Could be a new DB core principle... or plugged it everywhere we could store a string... 

- seen as Structured Document Model (xml like, and so (x)html or any other variant)
	- First Level
	- allow update/modification
	- allow query
	- allow generic GUI
	- allow validation

- seen as an ADT

- seen as AST
	- allow meta-programation
	- allow full introspection
	- allow auto testing (particulary with if/each)
	- allow fastest and cleanest diffing
		=> AST is the highest tree : much more cutable
		=> AST is stable : no hard transformation of nodes

- seen as Model or Transformation Rule in Model Driven Approach
	- allow translations/transformations between models
	- allow environment dependent interpretation/implementation/output
	- allow documentation and reports auto generations
	==> That's complete and real MDD that rocks

	It even explains why classical MDD based on UML is a failure :
	- UML is a set of fixed DSLs (class, sequence, use case, ... diagrams and their lexems).
	- classical MDD means using ONE language (UML) on top
	and impose to express any problems through its DSLs (and derived Dialects) 
	and impose to do that at each level

	DS(M)M says that top language should be ad'hoc and precisly defined, 
	and so different for all kind of treated problems. 
	We use directly the right language and impose nothing.
	It allows easy connection between Models and natural structuration.

- seen as Web Ontology Bridge
	- easy classification
	- ontologic friendly
	- allow best precision query
	- declarative is suffisiant
	==> Welcome to Babelute DSL Core
	==> Best quality SEO

- seen as Machine Intelligence Tools
	- allow inference
	- allow pattern or similarity discovering
	- allow continuous feeding
	==> DS(M)M is how we think
	==> babelute's transformations are the exact inverse processus than recognition
	==> babelute is what we have in mind when we have correctly understoud something
	==> full link with deep-learning

	==> Rich and smart data make us (and machines) more inteligent

	(cela plaide en faveur d'une IA forte)

- seen as Formal Gramar
	- lexic + documentation rules = formal gramar
	==> we could use it to parse/recognize atoms to compounds
	==> it's easy to automaticaly derivate the Finit State Machine needed to do the job nicely
	==> which could be LL(k) due to natural tree structuration and left-to-right writing order

- seen as Software Development Method
	- Agile-that-never-been-so-easy : 
		allow really simple and direct almost-procedural method to design/develop/plan/iterate/...
	- method :
		- which is the domain ?
		- how do we talk about it ?
		- which are lexems ?
		- are they atoms or compounds ?
		- which transformations are needed ?
			- find target DSLs and iterate method
		- which implementations are needed ?
		- Don't Repeat Yourself (DRY)
		- be descriptive
		- be more DRY
		- think Domain purity. avoid Leaky Abstractions.
		- hide technologies deepest possible.

	==> easy iterate, easy change, easy design, easy reuse, easy instanciate, easy implement, easy represent, easy test, ...	
	==> welcome to DRY programing

	==> most pertinent, valuable, adequate result :
		For the end-customers : Domain are the most important. Not DB Model.
		Customer never change its business domain. Or he make another business.
		But he would change DB Model. And any software part.

	- allow full TDD approach :
		- we start by describing what we want, which is the key of TDD.
		- every level is atomically testable
		- divide to conquer. and iterate. then recompose. 
		==> Finally : everything is always, deeply, immediatly and often automatically testable.

And cherry-on-the-cake but not at all the least :
	- allow real and complete sharing of works : it's no more technologies, it's universal domain-model-data.
	- totally portable, totally reusable
	- Domains are the most stable things we have.
	- Shared DSL are true for today, yesterday and tomorrow (or almost)
	- each translation between DSL could drasticaly help developpers community
	
	==> Welcome in Sharing Era




So from a simple tree we have derivate through :
	- Internal Fluent DSLs and Semantic Era
	- Descriptive Templating 
	- Facade Simplicity
	- Smart Interchangeable Data Modeling
	- Structured Document Model
	- AST
	- Model/Transfo in MDD
	- The missing Web Ontology Bridge
	- Machine Intelligence Tools
	- Automatisable Formal Gramar
	- Agile/TDD dev method
	- Sharing Era

Each time you write any babelute : you receive ALL this for the same price.
And if you use the right lexic, with well choosed lexems, you should have the purest form, optimaly exposed, semanticaly perfect (in regard of actual domain knowledge) view of your problem and its resolution(s).

And if you don't, it's just because you (or humanity) haven't fully understand yet the problem you search to resolve. Because you simply missing how to make clear sentences that expose practically and unambigously what you want.

And all Babelute interest come from that : many highly different modern Software Engineering foundamentals aspects are gathered, elegantly resolved and transported implicitly (but unambigously) on a simple tree data structure, that should reflect, in an ideal world, the best knowledge avaiable from a Domain.

Particulary, this simple data structure form the simplest and complete bridge between highly practical development considerations (we want to produce clean code quickly and simply) and highly theorical ones (Machine Learning, Data-Science, Ontologies, Software Dev Method, ...).

And all that is accessible in any general-purpose-coding-language.

For all this reason,  Babelute should become :
	- the next gen Light Practical Ontology System
		- used heavily by all Search Engine and Machine Intelligence actors
		- and so exposed by web/app/data/... actors
	- the next gen Data Interchange Format with native parsers in actual VMs/Compilers/STD/... (js with browsers, node, ... and of course any others general-purpose language)
	- the next gen standards for MDD
	- the next gen smart DB core principle
	- the next gen Agile Method Canvas
	- the next gen paradigm that everybody should learn at school : everybody is a scripter
	- the biggest IT community, working around Babelute DSL core

There is two universal answers to every question... 42 and Babelute... ;)



So we have migrate from : 
Software Design
Data Design
Knowledge Design
Sentences for everything




=> Notion de safe dependencies update : (de nouveau : WOW !!)
	check si arbre de dépendances peut être updaté : exemple : toolschain dsl : comme on connait la version du DSL babelute utilisé pour décrire le tools chain : 
		on peut savoir si (et jusqu'ou) on peut avancer de version pour le moteur d'interprétation

	bcp mieux que supputation versionning sémantique




# Postface

What have been discussed before are IT related point of views.

But there are (much) more transversal links :
As Systemic, autogeneration and law design : DSLs are highly generative systems because of freedom of sentences construction (which is one of the key of the world complexity) (For the little history : it's really one of the foundamentals theory which has lead to babelute development)

From that point we could derive to Government Policies, to Evolution Theory and many more seemly unrelated Domain

or ADN link : understanding ADN sequence is finding DSL sentences that has produce them

Or even more highly Theorical considerations
As Dsl and Goedel Incompletude Theorem : as we define languages that produce ASTs, we should work with complete languages (no cycles)
or DSM/Babelute Tools Theory








https://en.wikipedia.org/wiki/Fluent_interface

Tools Theory


Information Quality Theory


https://en.wikipedia.org/wiki/Pragmatics  == Actions

https://en.wikipedia.org/wiki/Semantics

https://en.wikipedia.org/wiki/Semantic_data_model


https://en.wikipedia.org/wiki/Information_model

Fact-based Modeling

https://en.wikipedia.org/wiki/Object-role_modeling#Fact-based_modeling

http://www.slideshare.net/drrubrico/semantics-meanings-of-language

Systemic Connection : 

	Atom + Compounds = Element of the system + Interactions = words from lexics

	Interactions Sequences = sentences

	System is mush more than its parts sum.
	System is element, interactions grammar, AND sequences.

	Systemic talks about generability.

	System Qualities Theory
		most important quality : genarability

		Because we are human : 
			we need also : simplicity, understandibility


http://link.springer.com/chapter/10.1007/11568346_41

http://www.slideshare.net/baojie_iowa/semantic-information-theory-in-20-minutes

 syntactic compression methods

Measuring the Perceived Semantic Quality of Information Models
http://www.sciencedirect.com/science/article/pii/S1574119213000953



Sentences are everything.
	Think about your code. Is just sentences made with few keywords and some literals and some characteres to delimit and structure.
	Think about algebra... Same thing... just sentences. 
	And they are both so powerful. So much smart things have been written with them...

	The good news is that (almost) all human activities are naturaly described by sentences.
	Sure that to explain finely a mouvement only with words is not easy by example...
	But we could easily desribe the whole humanity history and so much more with relatively few words.

	Sentences are how our brain works when it reasons or communicates.
	It's all about playing with right words along with well choosed abstraction level and structure.
	With that, we are able to generate an infinity of smart thinking.

	And DSLs (all of them, from any domains of real life) are what communities have forged, often since decade, with expertise and patience, and that has become the way of thinking their problems.
	In fact, DSLs catch the knowledge of their respective domain in few words and allow us to make sentences with them.


Universal Unambigous Sentences 
	
	General Definition of Information (GDI) compliance

		Factual 
		Instructional

	Applications
		- SEO, Data Science and Ontology Bridge

		- Technology Agnostic Informations : welcome in sharing era.


	Informations 
		= Data + meaning ==> meaning = DSL grammar = lexems relations
		= data + questions 
		= primary + meta + derivated

		==> Information = Data + grammar + meta + derivated (questions answers)

	Level Of Abstraction



Third revolution : 

http://www.developerdotstar.com/mag/articles/PDF/DevDotStar_Kelly_DomainModeling.pdf



Critère de comparaison de DSL :

	- active or not (factual/instructional, description/action)

	- agnosticity purity
	- atom/shortcut/compounds ratios
	- level purity


La désambiguïsation lexicale est la détermination du sens d'un mot dans une phrase lorsque ce mot peut avoir plusieurs sens possibles. Dans la linguistique informatique, la désambiguïsation lexicale est un problème non résolu dans le traitement des langues naturelles et de l'ontologie informatique.
Désambiguïsation lexicale — Wikipédia
https://fr.wikipedia.org/wiki/Désambiguïsation_lexicale

Word-sense disambiguation
In computational linguistics, word-sense disambiguation (WSD) is an open problem of natural language processing and ontology. WSD is identifying which sense of a word (i.e. meaning) is used in a sentence, when the word has multiple meanings. The solution to this problem impacts other computer-related writing, such as discourse, improving relevance of search engines, anaphora resolution, coherence, inference et cetera.
https://en.wikipedia.org/wiki/Word-sense_disambiguation

https://en.wikipedia.org/wiki/Lexical_semantics#Semantic_networks

https://en.wikipedia.org/wiki/Pragmatic_theory_of_information

https://plato.stanford.edu/entries/information-semantic/#1.2

http://octavia.zoology.washington.edu/publications/BergstromAndRosvall09.pdf

http://wiki.aardrock.com/Semantic_Transmission_and_the_Emergent_Mind

http://visual-memory.co.uk/daniel/Documents/short/trans.html#G

https://en.wikipedia.org/wiki/Semantic_change

http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.295.4692&rep=rep1&type=pdf

https://bi.snu.ac.kr/~scai/Info/AI/Fusion,%20Propagation,%20and%20Structuring%20in%20Belief%20Networks.pdf

http://philsci-archive.pitt.edu/2536/1/iimd.pdf

http://www.secc.org.eg/RECOCAPE/Documents/SECC_Tutorials_MDD_Getting-started-with-MDD-and-DSM.pdf

 * Domain Specific (Multi)Modeling (using DSL at all levels) solves many software design problems.
 * From developpement process (how to start, what and how to design, how to iterate, ...) 
 * to how to understand, design and articulate business related problems and/or pure code logics.

What is Domain-Specific Modeling?

Domain-Specific Modeling raises the level of abstraction beyond programming by specifying the solution directly using domain concepts. The final products are generated from these high-level specifications. This automation is possible because both the language and generators need fit the requirements of only one company and domain. Your expert defines them, your developers use them.

Industrial experiences of DSM consistently show it to be 5-10 times faster than current practices, including current UML-based implementations of MDA. As Booch et al. say* "the full value of MDA is only achieved when the modeling concepts map directly to domain concepts rather than computer technology concepts." For example, DSM for cell phone software would have concepts like "Soft key button", "SMS" and "Ring tone", and generators to create calls to corresponding code components. DSM fulfils the promise of model-driven development.

Since your expert specifies the code generators - for your domain and your components - the resulting code is better than most developers write by hand. No "one size fits all" generated code, no stubs, no "round trip" problems. Instead, full, top quality code. DSM does to code what compilers did to assembly language.



antifotizomai (exposed to light)
ekthésimos (exposed - isolable)
ektheatrízo (exposed on stage)
enaíthrios (fully exposed)
diafrazo (show plainly)

Good DSL developpement is the exact opposite than Cryptography


Le fait de laisser la place à l'interprétation ultétrieur permet de variabiliser le programme lui même.

Quad on écrit avec le DSL : on choisit des mot comme des variables qui pourront prendre plein de "valeus" différentes.

avec babelute-html (ou idem si css)
	quand j'utilise le mot .monComponent(...) 

	je permet de redéfinir le mot de manière libre


Il faut voir Babelute comme un esprima selectif ultra lightweight