
Todo :

_each and _if should be shortcuted to .if and .each in FirstDegreeMode

facade initializer
	var h = Babelute.facadeInitializer('html', 'html:dom')
	h('#body').span('bloupi').div('floupi')


still to finalise objects and array translations theory

i18n : check different ways to achieve it (external dico or internal _translation)
	 		
do simple example with async manager in env

translation/output table


Use ES6 classes definition

// Direct Babelute Class handling
+ Babelute.createFirstDegreeInitializer(BabeluteClass)
+ Babelute.createInitializer(BabeluteClass)
+ Babelute.addAtom(class, name, ..., ..., ...);
+ Babelute.addLexem(class, name, method);


create Lexic class
==> lazzy production of firstDegree and initializer

+ .extend('new-name')
+ .firstDegreeInitializer()
+ .initializer()
+ .useInstance()

+ Babelute.addLexic(lexic);


create Action (abstract) class
	with restrictions
	+ .addRestriction(...)
	+ .extend('new-name')

create FacadeActions class
with facade output style engine
.output(subject, env);
+ .facadeInitializer()


create PromiseFacadeActions class
with Promised Facade output style engine
.output(subject, env);
+ .facadeInitializer()




//_____________ after

CLI : 
	babelute -r myhtml.js #myhtml:myComponent('hello') -$ html:string > ./my-file.html
	babelute -r myapp.js

		==> open interactive nodejs with myapp loaded and Babelute on root

work on babelute doc pilot : external query DSL ? api ?
		.0 = args[0]
		.name = select lexems with matching name
		.#lexic = select lexems with matching lexic
		.#lexic:lexem = select lexems with matching lexic and lexem name
		.*
		.*(filter)
		.**(0=is=babelute)
	 	.**(div|span|#foo:goo.0=is=babelute)
	
	add tests
